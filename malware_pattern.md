Below is a **research-backed** set of **co‑occurrence patterns (2020–2025)** you can encode on top of your catalog **without introducing new false negatives relative to your current workflow**.

I’m going to be very explicit about:

1. **What “no false negative” can mean here** (and what it can’t)
2. **Which malware behaviors repeatedly co-occur in the wild (with evidence)**
3. **Concrete pattern definitions using your category IDs**
4. **A scoring strategy that is “fail-open” (additive-only) so patterns never become a prerequisite for surfacing a block**

---

## 1) “No false negatives” in your architecture

With a static, signature-based detector, you can’t *guarantee* “no false negatives” against unknown future variants (malware can always avoid a specific API signature). But you *can* guarantee:

* **No additional false negatives introduced by the new co-occurrence scoring**, compared to your baseline catalog hits, by enforcing:

  * **Base score = max(weight)** (or your current priority-based ordering) always preserved.
  * **Co-occurrence only adds boosts / can only promote priority**, never demotes.
  * **Never require a pattern match to flag / keep / output a block**.

This is important because a lot of real malware is modular: some samples show only part of the chain in one block (dropper vs payload), and you don’t want to hide those.

---

## 2) What co-occurs in real Android malware (2020–2025)

### A) Dropper → install payload → request Accessibility → overlay/ODF

This chain shows up repeatedly:

* ThreatFabric describes **droppers on Google Play** that **download payloads (e.g., from GitHub) and install them**, and then the banking trojan payload requests **AccessibilityService** to do overlays/actions.
* Cleafy’s TrickMo writeup shows a **dropper installing another APK**, then guiding users into **Settings** to enable **Accessibility**, and then doing OTP interception + overlays + remote control, etc.
* NCC Group’s SharkBot analysis describes **dropper behavior**, then classic banking behaviors like overlays, keylogging via accessibility, SMS interception/hiding, and ATS/remote control.

**Detection takeaway:** If you see `SYSTEM_MANIPULATION_PACKAGE` co-occurring with any delivery/settings-lure/persistence indicator, treat that block as a likely **dropper / stage-0** even if it doesn’t yet show the “big scary” APIs.

---

### B) Banking trojans: Accessibility + overlays/web injections + app targeting

This is one of the most stable co-occurrences across 2020–2025:

* FluBot: requests accessibility; detects banking/crypto apps; shows **fake overlay** to steal credentials.
* SharkBot: uses **overlay/WebView injections**, **keylogging via Accessibility**, and SMS interception/hiding.
* Crocodilus: requests **Accessibility**, connects to C2, monitors app launches, and shows overlays; captures OTP-like codes (e.g., authenticator) and uses “black screen” style overlays.

**Detection takeaway:** The combo `ABUSE_ACCESSIBILITY` + (`INPUT_PROMPT_OVERLAY` or `WEBVIEW_PHISHING`) is high-confidence. But don’t require overlay—many ODF/ATS variants can operate with accessibility + remote commands alone.

---

### C) ODF / ATS / full device takeover: Accessibility + input injection + screen streaming

Modern ODF banking malware increasingly includes “operator-like” remote control:

* ThreatFabric explicitly calls out the rise of **On‑Device Fraud (ODF)** and **Automated Transfer System (ATS)** behaviors powered by Accessibility.
* TeaBot: remote control through Accessibility and **real-time screen sharing**, plus overlays and SMS interception/hiding.
* TrickMo: remote control, gestures/clicks, VNC, screen recording, ignore battery optimizations, disable notifications, etc.
* Hook v3 (Zimperium): Accessibility abuse + transparent overlays capturing gestures + screen streaming; also ransomware-style overlays.

**Detection takeaway:** If `ABUSE_ACCESSIBILITY` co-occurs with `INPUT_INJECTION` and/or `SURVEILLANCE_SCREEN_CAPTURE`, treat as **ODF/ATS capable**, even if no overlay is present in that same block.

---

### D) OTP theft: SMS interception + notification capture/suppression

Two parallel OTP paths show up repeatedly:

1. **SMS interception** (BroadcastReceiver / ContentObserver / becoming default SMS app)
2. **Notification listener** (read OTP from notification text; suppress it so user never sees it)

Evidence:

* EventBot: abuses accessibility + reads/intercepts SMS to bypass 2FA.
* Microsoft toll-fraud research: intercepts OTP and **suppresses SMS notifications**, explicitly via `NotificationListenerService` cancellation APIs.
* TrickMo: explicitly “handling notifications to intercept or hide authentication codes,” plus SMS interception.

**Detection takeaway:** Your earlier `otp_theft = {COLLECTION_NOTIFICATIONS, INTERCEPT_SMS_MESSAGES}` is good, but the *stronger real-world co-occurrence* is:

* `INTERCEPT_SMS_MESSAGES` + `DEFENSE_EVASION_NOTIFICATION_SUPPRESSION`
* `COLLECTION_NOTIFICATIONS` + `DEFENSE_EVASION_NOTIFICATION_SUPPRESSION`

---

### E) Smishing propagation: send SMS + contacts + C2

* FluBot campaigns famously use infected devices to send SMS to spread (“smishing”), while also using accessibility/overlays for banking theft.

**Detection takeaway:** `SMS_CONTROL_SEND` + (`COLLECTION_CONTACTS` or `COLLECTION_SMS_MESSAGES`) + `C2_NETWORKING` is a strong propagation signature.

---

### F) Stalkerware: persistence hardening + “bundle” surveillance collection

Stalkerware/spyware is “bundle heavy”: it tends to combine many collection capabilities with persistence tricks.

The large arXiv study (2025) explicitly notes:

* Frequent instructions to **disable battery optimization**
* Use of **device administrator** to evade battery optimization/uninstall
* Use of **SMS commands** and network to receive commands and trigger actions

**Detection takeaway:** A stalkerware-like block often looks like:

* multiple of {location, SMS, contacts, call log, microphone, camera}
* plus persistence (`PERSISTENCE_BATTERY_OPTIMIZATION_ALLOWLIST`, `PERSISTENCE_*`) and/or device admin

---

### G) Push as C2 “wake-up”: FCM + follow-up fetch/redirect

* Cisco Talos Firestarter: FCM as a **mandatory** comms channel; used to notify payload location and redirect to new C2.

**Detection takeaway:** `C2_PUSH_FCM` alone is weak/benign (tons of legitimate apps). But `C2_PUSH_FCM` + `DYNAMIC_CODE_LOADING` or `C2_NETWORKING` (or any strong stealing capability) is suspicious.

---

## 3) Concrete co-occurrence patterns to encode (category IDs)

### Design principle

Use **two layers per behavior** to avoid false negatives:

* **Strong match** (tight AND) → larger boost / optional priority promotion
* **Weak match** (looser AND/OR) → small boost (so variants still get lift)

Below are **drop-in pattern definitions** using your category IDs from the enhanced catalog.

---

### Pattern Set

#### 1) Dropper / staged install chain (HIGH signal)

**Why:** repeatedly observed in banking trojans (droppers installing payload; then payload asks accessibility).

* **P_DROP_INSTALL_VIA_DM**

  * `all_of`: `{SYSTEM_MANIPULATION_PACKAGE, DELIVERY_PAYLOAD_DOWNLOAD_DOWNLOADMANAGER}`
  * `boost`: `+0.20`
  * `priority_override`: `HIGH`

* **P_DROP_INSTALL_VIA_NET**

  * `all_of`: `{SYSTEM_MANIPULATION_PACKAGE, C2_NETWORKING}`
  * `boost`: `+0.15`
  * `priority_override`: `HIGH`

* **P_DROP_INSTALL_SETTINGS_LURE**

  * `all_of`: `{SYSTEM_MANIPULATION_PACKAGE, SOCIAL_ENGINEERING_PERMISSION_LURE_SETTINGS}`
  * `boost`: `+0.20`
  * `priority_override`: `HIGH`

* **P_DROP_TO_ACCESSIBILITY**

  * `all_of`: `{SYSTEM_MANIPULATION_PACKAGE, ABUSE_ACCESSIBILITY}`
  * `boost`: `+0.25`
  * `priority_override`: `CRITICAL`
    (This catches “install + immediately ask for Accessibility” seen in multiple reports.)

**False-negative safety:** even if the dropper uses neither DownloadManager nor your networking signatures, the install behavior alone remains surfaced by `SYSTEM_MANIPULATION_PACKAGE`. These patterns just *promote* likely droppers.

---

#### 2) Dynamic loader + evasion (packer/unpacker pattern)

**Why:** dynamic loading is heavily used to hide payload; often paired with crypto/reflection/anti-analysis.

* **P_DYNLOAD_EVASION**

  * `all_of`: `{DYNAMIC_CODE_LOADING}`
  * `any_of`: `{EVASION_CRYPTO_OBFUSCATION, EVASION_REFLECTION, ANTI_ANALYSIS_ANTI_DEBUG}`
  * `boost`: `+0.15`

* **P_NATIVELOAD_EVASION**

  * `all_of`: `{NATIVE_CODE_LOADING}`
  * `any_of`: `{EVASION_CRYPTO_OBFUSCATION, ANTI_ANALYSIS_ANTI_DEBUG}`
  * `boost`: `+0.12`

**False-negative safety:** dynamic loading is already CRITICAL in your catalog; this only improves ranking/context when obfuscation co-occurs.

---

#### 3) ODF / ATS / “full device takeover”

**Why:** Accessibility-driven automation + remote control + streaming is the core of modern ODF.

* **P_ODF_REMOTE_STREAM**

  * `all_of`: `{ABUSE_ACCESSIBILITY, SURVEILLANCE_SCREEN_CAPTURE}`
  * `any_of`: `{C2_NETWORKING, C2_PUSH_FCM}`
  * `boost`: `+0.25`
  * `priority_override`: `CRITICAL`

* **P_ODF_INPUT_AUTOMATION**

  * `all_of`: `{ABUSE_ACCESSIBILITY, INPUT_INJECTION}`
  * `any_of`: `{C2_NETWORKING, C2_PUSH_FCM}`
  * `boost`: `+0.20`
  * `priority_override`: `CRITICAL`

* **P_ODF_OVERLAY_OR_WEBINJECT**

  * `all_of`: `{ABUSE_ACCESSIBILITY}`
  * `any_of`: `{INPUT_PROMPT_OVERLAY, WEBVIEW_PHISHING}`
  * `boost`: `+0.20`
  * `priority_override`: `CRITICAL`
    (Matches FluBot/SharkBot/Crocodilus style theft flows.)

**False-negative safety:** if malware uses accessibility-only ATS with no overlay/streaming in the same block, it still scores as CRITICAL from `ABUSE_ACCESSIBILITY`.

---

#### 4) OTP theft (SMS + notifications)

**Why:** OTP is stolen either from SMS or from notification text, and often hidden from user.

* **P_OTP_SMS_INTERCEPT_EXFIL**

  * `all_of`: `{INTERCEPT_SMS_MESSAGES}`
  * `any_of`: `{C2_NETWORKING, EXFIL_ALTERNATIVE_PROTOCOL}`
  * `boost`: `+0.15`

* **P_OTP_NOTIFICATION_CAPTURE_AND_HIDE**

  * `all_of`: `{COLLECTION_NOTIFICATIONS, DEFENSE_EVASION_NOTIFICATION_SUPPRESSION}`
  * `boost`: `+0.20`
    (Directly mirrors Microsoft’s NLS abuse path.)

* **P_OTP_SMS_AND_NOTIFICATION_HIDE**

  * `all_of`: `{INTERCEPT_SMS_MESSAGES, DEFENSE_EVASION_NOTIFICATION_SUPPRESSION}`
  * `boost`: `+0.25`
  * `priority_override`: `CRITICAL`

---

#### 5) Smishing propagation

**Why:** FluBot-style self-propagation combines send-SMS + contact harvesting + C2.

* **P_SMISHING_SPREAD**

  * `all_of`: `{SMS_CONTROL_SEND, C2_NETWORKING}`
  * `any_of`: `{COLLECTION_CONTACTS, COLLECTION_SMS_MESSAGES}`
  * `boost`: `+0.20`
  * `priority_override`: `HIGH`

---

#### 6) Stalkerware / spyware bundle + persistence hardening

**Why:** stalkerware frequently bundles multiple collection capabilities and instructs disabling battery optimization; device admin is also used to evade restrictions/uninstall.

* **P_STALKERWARE_PERSIST_LOCATION**

  * `all_of`: `{SURVEILLANCE_LOCATION, PERSISTENCE_BATTERY_OPTIMIZATION_ALLOWLIST}`
  * `any_of`: `{PERSISTENCE_BROADCAST_RECEIVERS, PERSISTENCE_SCHEDULED_TASKS, PERSISTENCE_FOREGROUND_SERVICE}`
  * `boost`: `+0.20`

* **P_STALKERWARE_COLLECTION_BUNDLE**

  * `min_count_of`: `3`
  * `from_set`: `{SURVEILLANCE_LOCATION, SURVEILLANCE_AUDIO, SURVEILLANCE_CAMERA, COLLECTION_SMS_MESSAGES, COLLECTION_CONTACTS, COLLECTION_CALL_LOG, COLLECTION_FILES_MEDIA}`
  * `boost`: `+0.25`
  * `priority_override`: `HIGH`

* **P_STALKERWARE_SMS_COMMAND_CONTROL**

  * `all_of`: `{C2_NETWORKING}`
  * `any_of`: `{COLLECTION_SMS_MESSAGES, INTERCEPT_SMS_MESSAGES}`
  * `any_of_2`: `{PERSISTENCE_BROADCAST_RECEIVERS, PERSISTENCE_SCHEDULED_TASKS}`
  * `boost`: `+0.15`
    (Reflects “SMS commands + network commands + persistence” noted in the arXiv corpus.)

---

#### 7) Push wake-up C2 (FCM) **only when paired**

**Why:** FCM alone is too common; but FCM + follow-on loader/network is used in real malware.

* **P_PUSH_WAKEUP_THEN_FETCH**

  * `all_of`: `{C2_PUSH_FCM}`
  * `any_of`: `{C2_NETWORKING, DYNAMIC_CODE_LOADING}`
  * `boost`: `+0.10`

---

## 4) How to implement this “fail-open” (no new false negatives)

### Key changes vs your earlier plan

* **Remove / disable ENABLER_SOLO_PENALTY by default**
  Penalizing “enabler-only” blocks is the #1 way people accidentally create false negatives in triage pipelines (because droppers/stage‑0 often look like “just install+settings+download”). ThreatFabric explicitly describes droppers as the entry point.

* **Allow priority promotion, never demotion**
  If a dropper chain pattern matches, override the block priority upward (e.g., to HIGH) so it’s not buried beneath noisy CRITICALs in unrelated code.

### Concrete scoring rules

Use:

* `base_score = max(weights)`  ✅ (unchanged, preserves existing recall)
* `synergy_boost = Σ boosts for matched patterns`
* `final_score = min(base_score + synergy_boost, 1.0)` ✅
* `priority = min(priority_max, best_priority_override)` ✅ (promotion only)

### Pattern matcher structure (precise)

Extend your `ESCALATION_PATTERNS` format to support:

* `all_of` (set must be subset)
* `any_of` (intersection non-empty)
* `min_count_of` + `from_set`

And optionally multiple any-of groups (`any_of_2`) if you want to express “A + (B or C) + (D or E)”.

---

## 5) One *very* important addition for toll-fraud (optional but high value)

Microsoft’s toll-fraud analysis shows a very distinctive co-occurrence:

* operator gating via `TelephonyManager.getSimOperator()` / `SystemProperties.get(...)` (often via reflection)
* dynamic code loading
* intercept OTP
* suppress notifications via NotificationListenerService cancellation APIs

If you want to cover toll fraud better, add **two new categories** (signature-only, fits your workflow):

* `TOLL_FRAUD_OPERATOR_GATING`

  * `android.telephony.TelephonyManager->getSimOperator()Ljava/lang/String;`
  * `android.telephony.TelephonyManager->getNetworkOperator()Ljava/lang/String;`
  * (optional) `android.os.SystemProperties->get(Ljava/lang/String;)Ljava/lang/String;` (often reflect-invoked)

* `TOLL_FRAUD_FORCE_CELLULAR`

  * `android.net.ConnectivityManager->requestNetwork(Landroid/net/NetworkRequest;Landroid/net/ConnectivityManager$NetworkCallback;)V`
  * `android.net.wifi.WifiManager->setWifiEnabled(Z)Z`

Then add pattern:

* **P_TOLL_FRAUD_CHAIN**

  * `all_of`: `{DYNAMIC_CODE_LOADING, DEFENSE_EVASION_NOTIFICATION_SUPPRESSION}`
  * `any_of`: `{TOLL_FRAUD_OPERATOR_GATING, TOLL_FRAUD_FORCE_CELLULAR}`
  * `boost`: `+0.20`

This is both **high-signal** and still **pattern-only additive**, so it won’t create false negatives.

---

## Bottom line improvement vs your current “3 patterns”

Your current 3-pattern plan (dropper_loader / ats_phishing / otp_theft) is a good start, but it misses several *real* co-occurrences that repeatedly show up in 2020–2025 malware:

* **Install-chain droppers** (install + settings lure + download)
* **NotificationListenerService capture + suppression** (very common for OTP hiding)
* **ODF remote streaming / gesture automation** (ATS/ODF direction of travel)
* **Stalkerware “bundle + persistence hardening”** (huge ecosystem, very patternable)
* **FCM push wake-up chained to fetch/loader**

And the “no false negative” safeguard is simply: **never subtract risk; never require a co-occurrence to flag; only use co-occurrence to promote.**

If you want, I can rewrite your `ESCALATION_PATTERNS` block into a drop-in Python dict using the exact matcher semantics above (including `min_count_of`) so you can paste it directly into `orchestrator.py`.
